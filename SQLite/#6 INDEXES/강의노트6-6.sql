DB 엔진은 내부적으로 query plan을 가지고 있음

인공지능처럼 똑똑해서 너가 작성한 쿼리를 가지고 나의 데이터를 산출하기 위한 최적화된 알고리즘을 도출한다

가장 시간이 덜 걸리는 방법으로

SQL은 선언적인 언어이기 때문에 query planner에게 무엇을 해야할지 말해줄 필요가 없다

다양한 조건과 CTE, subquery 등 원하는 것들을 작성하면 query planner가 언제 어떤 조건을 실행하고 어느 조건이 먼저 가야하는지 알아서 한다

하지만 가끔 query planner도 도움이 필요할 때가 있다

이럴 때 내가 query planner에게 도움을 줄 수 있는데 예를 들어 query planner에게 나는 감독을 기준으로 아주 많이 검색할거야 그래서 널 돕고싶어

이 때가 바로 INDEX를 생성할 때이다

INDEX는 너의 메인 데이터를 저장하고 있는 데이터 구조와는 별개의 데이터 구조다

INDEX는 별개의 데이터 구조이며 이 구조는 검색을 하기에 매우 최적화되어 있어서 요소들을 빨리 찾을 수 있다



B+ Tree(MySQL) 혹은 B Tree(SQLite, PostgreSQL)는 단계별로 절반의 옵션을 제거하는 이진 탐색을 사용한다.

Table Scan보다 적은 단계를 거치지만 

INDEX는 공짜가 아니다

INDEX는 개별적으로 저장되는 데이터 구조이고 그 말은 너의 INDEX를 어딘가에 저장해두어야 한다

즉 너의 하드 드라이브에 또 다른걸 저장해야 한다는 말이다

INDEX를 생성한다면 그 데이터는 복제된거나 다름없다, 중복된 데이터를 가지게 된다

INDEX는 디스크 공간을 차지할 뿐더러 나의 DB에서 추가, 수정, 삭제를 느리게 만든다는 점에서 비용이 든다

메인 db에 데이터를 추가, 수정, 삭제할 때마다 INDEX도 업데이트를 해야한다


내가 Pedro가 감독한 영화를 찾으려고 한다면 DB는 INDEX를 사용해서 leaf node를 찾고 Pedro가 감독한 모든 영화의 id를 수집한다

그러곤 메인 테이블로 점프해서 영화를 찾고 나에게 영화 제목을 알려줌